name: Actualizar Datos y Modelo ETH

permissions:
  contents: write # Permite que el workflow escriba en el repositorio (para los commits)

on:
  schedule:
    # Ejecuta el workflow todos los días a medianoche (UTC).
    # Puedes ajustar la frecuencia si lo deseas.
    - cron: '0 0 * * *'
  push:
    # Ejecuta el workflow cada vez que se hace un push a la rama 'main'.
    branches:
      - main
  workflow_dispatch:
    # Permite ejecutar el workflow manualmente desde la interfaz de GitHub.

# Jobs a ejecutar
jobs:
  actualizar_datos_y_modelo: # Renombrado el job para reflejar su nueva función
    runs-on: ubuntu-latest # Ejecuta el job en un entorno Ubuntu

    steps:
      - name: 1. Checkout del código
        uses: actions/checkout@v4 # Descarga el código de tu repositorio
        with:
          # No necesitamos fetch-depth: 0 si vamos a forzar el push de los artefactos
          # y no estamos fusionando historiales complejos.
          # Sin embargo, lo mantendremos por si acaso el futuro.
          fetch-depth: 0 

      - name: 2. Configurar Python 3.9
        uses: actions/setup-python@v5 # Configura el entorno Python
        with:
          python-version: '3.9' # Especifica la versión de Python a usar

      - name: 3. Instalar dependencias
        run: |
          python -m pip install --upgrade pip # Asegura que pip esté actualizado
          pip install -r requirements.txt # Instala todas las bibliotecas de tu requirements.txt

      - name: 4. Ejecutar script de recolección de datos (Collector)
        # RUTA CORREGIDA: asumiendo que collector.py está en src/proyecto/static/models/
        run: |
          python src/proyecto/static/models/collector.py

      - name: 5. Ejecutar script de enriquecimiento de datos (Enricher)
        # Ruta para enricher.py
        run: |
          python src/enricher.py

      - name: 6. Ejecutar script de modelado (Modeller)
        # Ruta para modeller.py
        run: |
          python src/modeller.py

      - name: 7. Listar archivos y directorios (para depuración)
        # Útil para verificar que los archivos se están creando en las rutas esperadas
        run: ls -lR

      - name: 8. Commit y subir cambios
        run: |
          # Configura la identidad de Git para el commit automático
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Añade los archivos generados, forzando su adición a pesar de .gitignore
          # NO USAMOS 'git add .' aquí para evitar conflictos con otros archivos de código
          git add -f src/proyecto/static/data/historical.db \
                     -f src/proyecto/static/data/historical.csv \
                     -f src/proyecto/static/data/enriched_historical.db \
                     -f src/proyecto/static/models/model.pkl \
                     -f src/proyecto/static/models/collector.log \
                     -f src/proyecto/static/models/enricher.log \
                     -f src/proyecto/static/models/modeller.log
          
          # Crea un commit SOLO si hay cambios en los archivos añadidos.
          # El '|| true' es importante para que el paso no falle si no hay cambios.
          git commit -m "Actualizar datos, enriquecimiento y modelo (Tarea 2 automatizada)" || true
          
          # --- ¡CAMBIO CRÍTICO AQUÍ! ---
          # Si el commit fue exitoso (es decir, hubo cambios), entonces hacemos un push.
          # Usamos 'git push --force-with-lease' para sobrescribir los archivos generados
          # Esto es más seguro que un 'git push --force' puro.
          # Solo se hace push si el commit anterior no fue 'no changes to commit'.
          if git diff --cached --exit-code; then
              echo "No hay cambios para subir."
          else
              echo "Subiendo cambios..."
              git push --force-with-lease origin main
          fi
